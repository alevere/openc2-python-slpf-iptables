#!/usr/bin/env python 
#
#  The MIT License (MIT)
#
# Copyright 2018 University of North Carolina at Chapel Hill. All other rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software
# and associated documentation files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or
# substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#

import subprocess
import json
import os
import sys
import signal

TIMEOUT=10
# top-level subroutine or function takes no arguments
# code for OpenC2 consumer
def main():
   # handle HTTP requests within 10s for UNIX/LINUX
   signal.signal(signal.SIGALRM, handler)
   signal.alarm(TIMEOUT)  
   # call function that will handle incoming requests from an OpenC2 producer
   request_handler()
   signal.alarm(0)

# alarm function to timeout requests
def handler(signum, frame):
   server_error(); 
   raise IOError("Couldn't open device!")

#function to handle GET, POST, cli request and make calls to other functions to execute commands
#figure out exactly what we want this function to do as far as parsing
def request_handler():
   conformance=0
   openc2_actions=['query', 'deny', 'allow', 'update', 'delete']
   openc2_targets=['file', 'ip_addr', 'ip_connection', 'openc2', 'slpf']
   request=sys.stdin.read()
   parsed_json = json.loads(request)
   #do we have an actions var
   for alpha in openc2_actions:
      if alpha==parsed_json['action']:
         conformance += 1
   if conformance!=1:
      not_parseable()
   else: 
      conformance=0

   #do we have a targets var
   for beta in openc2_targets:
      if beta in parsed_json.get("target"):
         conformance += 1
   if conformance!=1:
      not_parseable()
   else:
      conformance=0
      if parsed_json.get("action")==openc2_actions[0]:
         if openc2_targets[3] in parsed_json.get("target"):
            server_ok('success','pairs supported')
      else:
         sanitize(parsed_json.get("action"),'',parsed_json.get("target").get("ip_connection").get("src_addr"),'')
         execute_iptables(parsed_json.get("action"),parsed_json.get("target").get("ip_connection").get("src_addr"))

# tell producer something went wrong
def server_error():
   print('Status: 500 Internal Server Error')
   print('Content-Type: application/openc2+json;version=1.0')
   print('')
   print(json.dumps(['response', {'status': (500), 'status_text': 'server error'}], sort_keys=True, indent=4))
   print('')
   exit()

# tell producer we could not interpret request
def not_parseable():
   print('Status: 400 Bad Request')
   print('Content-Type: application/openc2+json;version=1.0')
   print('')
   print(json.dumps(['response', {'status': (400), 'status_text': 'unable to parse request'}], sort_keys=True, indent=4))
   print('')
   exit()

# tell producer things were ok
def server_ok(status_text_resp, resultant):
   print('Content-Type: application/openc2+json;version=1.0')
   print('')
   if len(resultant)>4:
      print(json.dumps({'status': (200), 'status_text': status_text_resp, 'results':{'pairs': [['allow', ['ip_connection']], ['deny', ['ip_connection']], ['query', ['openc2']]]}}, sort_keys=True, indent=4))
   else:
      print(json.dumps({'status': (200), 'status_text': status_text_resp}, sort_keys=True, indent=4))
   print('')

# function to sanitize untrusted input
def sanitize(action,protocol,source,destination):
   if len(action)>9:
      not_parseable()
   elif len(protocol)>6:
      not_parseable()
   elif len(source)>20:
      not_parseable()
   elif len(destination)>20:
      not_parseable()
   else:
      sanitized=1

# function to run iptables
# presently only supports denying or allowing a source IP 
def execute_iptables(action,source):
   if action=="deny":
      action_cli="DROP"
   elif action=="allow":
      action_cli="ACCEPT"
   else:
      server_error()
   # iptables command to review source IP and either allow or deny it
   command_line_args=f"/sbin/iptables --append INPUT --source {source} --jump {action_cli}"
   result=subprocess.run(['sudo','/sbin/iptables','--append','INPUT','--source',source,'--jump',action_cli], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
   server_ok('success','')
   #server_ok(result.stdout)
   #server_ok(result.stderr)

if __name__ == "__main__":
    main()
